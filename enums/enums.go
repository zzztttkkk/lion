package enums

import (
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"regexp"
	"runtime"
	"slices"
	"strings"
	"text/template"

	"github.com/zzztttkkk/lion"
)

type EnumOptions[T lion.IntType] struct {
	NamePrefix     string
	NameOverwrites map[T]string

	GenAllSlice           bool
	AllSliceName          string
	AllSliceNotPreDefined bool
	Hidens                []T
}

var (
	funcnameregexp = regexp.MustCompile(`^\.init\.\d+\.func\d+$`)
)

func Generate[T lion.IntType](fnc func() *EnumOptions[T]) {
	enumtype := lion.Typeof[T]()
	enumpkgpath := enumtype.PkgPath()
	enumpkgname := path.Base(enumpkgpath)

	runtimefunc := runtime.FuncForPC(reflect.ValueOf(fnc).Pointer())
	funcname := runtimefunc.Name()
	if !strings.HasPrefix(funcname, enumpkgpath) {
		panic(fmt.Errorf("lion.enums: fnc's pkg is not same as enum's pkg"))
	}
	if !funcnameregexp.MatchString(funcname[len(enumpkgpath):]) {
		panic(fmt.Errorf("lion.enums: `fuc` must be an anonymous function defined in the `init` function. `%s`", funcname))
	}
	filename, _ := runtimefunc.FileLine(0)
	dirname := filepath.Dir(filename)

	opts := fnc()
	if opts == nil {
		opts = &EnumOptions[T]{}
	}

	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(fset, dirname, nil, 0)
	if err != nil {
		panic(err)
	}

	pkg, ok := pkgs[enumpkgname]
	if !ok {
		return
	}

	var enums = map[string]*_EnumInfo{}
	var info = &_EnumInfo{}
	enums[enumtype.Name()] = info
	for _, file := range pkg.Files {
		_PopulateEnumInfo(enums, file)
	}
	if len(info.Consts) < 1 {
		panic(fmt.Errorf(`lion.enums: failed to scan enum values of '%s', you must define enum values like:
"""
const (
		A EnumType = iota
		B
		C
		.... 
)
"""
not:
"""
const (
		A = EnumType(iota)
		B
		C
		.... 
)
"""`, enumtype))
	}
	genGoCode(info, dirname, enumpkgname, opts, strings.HasSuffix(filename, "_test.go"))
}

func genGoCode[T lion.IntType](enuminfo *_EnumInfo, dirpath string, pkgname string, opts *EnumOptions[T], istest bool) {
	ftpl := `// Code generated by "github.com/zzztttkkk/lion/enums", DO NOT EDIT
package {{.pkgname}}

import "fmt"

func (ev {{.enumtypename}}) String() string {
	switch(ev){
		{{range .items}}
		case {{.vname}} : {
			return "{{.string}}"
		}
		{{end}}
		default: {
			panic(fmt.Errorf("{{.pkgname}}.{{.enumtypename}}: unknown enum value, %d", ev))
		} 
	}
}

{{if .defineallslice }}
var(
	{{.allslicename}} []{{.enumtypename}}
)
{{end}}
{{if .appendtoallslice}}
func init(){
	{{range .appenitems}}
	{{$.allslicename}} = append({{$.allslicename}}, {{.}})
	{{end}}
}
{{end}}
`
	items := []map[string]string{}
	for _, cv := range enuminfo.Consts {
		item := map[string]string{
			"vname":  cv.Name,
			"string": cv.Name,
		}
		if opts.NamePrefix != "" && strings.HasPrefix(cv.Name, opts.NamePrefix) {
			item["string"] = cv.Name[len(opts.NamePrefix):]
		}

		if opts.NameOverwrites != nil {
			ow := opts.NameOverwrites[T(reflect.ValueOf(cv.Value).Int())]
			if ow != "" {
				item["string"] = ow
			}
		}

		items = append(items, item)
	}
	val := map[string]any{
		"pkgname":      pkgname,
		"enumtypename": lion.Typeof[T]().Name(),
		"items":        items,
	}

	if opts.GenAllSlice {
		val["appendtoallslice"] = true

		name := opts.AllSliceName
		if name == "" {
			name = fmt.Sprintf("All%ss", lion.Typeof[T]().Name())
		}
		val["allslicename"] = name
		if opts.AllSliceNotPreDefined {
			val["defineallslice"] = true
		}

		appenditems := []string{}
		for _, cv := range enuminfo.Consts {
			if slices.IndexFunc(opts.Hidens, func(v T) bool {
				return reflect.ValueOf(cv.Value).Int() == reflect.ValueOf(v).Int()
			}) > -1 {
				continue
			}
			appenditems = append(appenditems, cv.Name)
		}

		val["appenitems"] = appenditems
	}

	sb := strings.Builder{}
	tpl := template.Must(template.New("").Parse(ftpl))
	err := tpl.Execute(&sb, val)
	if err != nil {
		panic(err)
	}

	testsuf := ""
	if istest {
		testsuf = "_test"
	}

	fp := fmt.Sprintf("%s/lion.enums.generate.%s%s.go", dirpath, lion.Typeof[T]().Name(), testsuf)
	f, err := os.OpenFile(fp, os.O_WRONLY|os.O_CREATE, 0o0755)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	f.Truncate(0)
	_, err = f.WriteString(sb.String())
	if err != nil {
		panic(err)
	}
}
